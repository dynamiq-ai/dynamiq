import base64
import io
import os

from dynamiq.connections import E2B
from dynamiq.nodes.agents.react import ReActAgent
from dynamiq.nodes.llms import Anthropic as AnthropicLLM
from dynamiq.nodes.tools.e2b_sandbox import E2BInterpreterTool
from dynamiq.nodes.types import InferenceMode
from dynamiq.utils.logger import logger

AGENT_ROLE = """
Senior Data Scientist and Programmer with the ability to write well-structured Python code.
You have access to E2B sandbox tools and the web to search for the best solutions to problems.
Generally, you follow these rules:
    - ALWAYS FORMAT YOUR RESPONSE IN MARKDOWN.
    - Use double quotes for property names.
    - Ensure the code is correct and runnable; reiterate if it does not work.
"""

PROMPT = """
Get required statistics from the file and compute them on a provided CSV file using E2B tool. Return markdown report.
"""

FILE_PATH = "./examples/use_cases/agents_use_cases/data/house_prices.csv"

FILE_DESCRIPTION = f"""
- The file is `{FILE_PATH}`.
- The CSV file uses a comma (`,`) as the delimiter.
- It contains the following columns (examples included):
    - bedrooms: number of bedrooms
    - bathrooms: number of bathrooms
    - price: price of a house
"""


def read_file_as_bytesio(file_path: str, filename: str = None, description: str = None) -> io.BytesIO:
    """
    Reads the content of a file and returns it as a BytesIO object with custom attributes for filename and description.

    Args:
        file_path (str): The path to the file.
        filename (str, optional): Custom filename for the BytesIO object.
        description (str, optional): Custom description for the BytesIO object.

    Returns:
        io.BytesIO: The file content in a BytesIO object with custom attributes.
    """
    with open(file_path, "rb") as f:
        file_content = f.read()

    file_io = io.BytesIO(file_content)

    file_io.name = filename if filename else "uploaded_file.csv"
    file_io.description = description if description else "No description provided"

    return file_io


def create_agent():
    """
    Create and configure the agent with E2B tools.

    Returns:
        ReActAgent: A configured Dynamiq ReActAgent ready to run.
    """
    tool = E2BInterpreterTool(name="code-executor", connection=E2B())

    llm = AnthropicLLM(
        name="claude",
        model="claude-sonnet-4-20250514",
        temperature=1,
        max_tokens=32000,
        thinking_enabled=True,
        budget_tokens=4000,
    )

    agent_software = ReActAgent(
        name="Agent",
        llm=llm,
        tools=[tool],
        role=AGENT_ROLE,
        max_loops=10,
        inference_mode=InferenceMode.XML,
    )

    return agent_software


def run_workflow(prompt: str, files_to_upload: list[io.BytesIO]) -> tuple[str, dict, dict]:
    """
    Main function to set up and run the workflow, handling any exceptions that may occur.

    Args:
        prompt (str): Question/task for the agent to accomplish.
        files_to_upload (List[io.BytesIO]): A list of BytesIO objects representing files to upload.

    Returns:
        tuple[str, dict, dict]: The content generated by the agent, intermediate steps, and any files generated.
    """
    try:
        agent = create_agent()

        result = agent.run(
            input_data={"input": prompt, "files": files_to_upload},
        )

        content = result.output.get("content")
        intermediate_steps = result.output.get("intermediate_steps", {})
        files = result.output.get("files", {})

        return content, intermediate_steps, files
    except Exception as e:
        logger.error(f"An error occurred: {e}")
        return "", {}, {}


def extract_base64_content(file_content: str) -> tuple[str, str | None]:
    """
    Extract base64 content from either data URI or plain base64 string.

    Args:
        file_content: Either a data URI (data:mime/type;base64,content) or plain base64

    Returns:
        Tuple of (base64_content, mime_type)
    """
    if file_content.startswith("data:"):
        try:
            header, base64_content = file_content.split(",", 1)
            mime_type = header.split(";")[0].replace("data:", "")
            return base64_content, mime_type
        except ValueError:
            return file_content, None
    else:
        return file_content, None


def get_file_extension_from_mime(mime_type: str) -> str:
    """
    Get appropriate file extension from MIME type.

    Args:
        mime_type: MIME type string

    Returns:
        File extension with dot (e.g., '.png')
    """
    mime_to_ext = {
        "image/png": ".png",
        "image/jpeg": ".jpg",
        "image/gif": ".gif",
        "image/webp": ".webp",
        "image/bmp": ".bmp",
        "image/svg+xml": ".svg",
        "application/pdf": ".pdf",
        "text/html": ".html",
        "text/css": ".css",
        "application/javascript": ".js",
        "text/plain": ".txt",
        "text/csv": ".csv",
        "application/json": ".json",
        "text/markdown": ".md",
    }

    return mime_to_ext.get(mime_type, "")


def save_agent_files(files: list[io.BytesIO] | dict, output_dir: str = "./agent_outputs") -> None:
    """
    Save files generated by agent, handling both BytesIO objects and legacy dictionary format.

    Args:
        files: List of BytesIO objects or dictionary mapping file paths to content (base64 or data URI)
        output_dir: Directory to save files to
    """
    if not files:
        print("No files to save.")
        return

    print("\n---------------------------------Generated Files-------------------------------------")

    # Handle new BytesIO format
    if isinstance(files, list):
        print(f"Agent generated {len(files)} file(s):")
        os.makedirs(output_dir, exist_ok=True)

        for file_bytesio in files:
            try:
                # Get file metadata from BytesIO object
                file_name = getattr(file_bytesio, "name", f"file_{id(file_bytesio)}.bin")
                file_description = getattr(file_bytesio, "description", "Generated file")
                content_type = getattr(file_bytesio, "content_type", "application/octet-stream")

                # Read content from BytesIO
                file_data = file_bytesio.read()
                file_bytesio.seek(0)  # Reset position for potential future reads

                # Determine file extension from content type if needed
                final_file_name = file_name
                if content_type != "application/octet-stream" and "." not in file_name:
                    extension = get_file_extension_from_mime(content_type)
                    if extension:
                        final_file_name = file_name + extension

                output_path = os.path.join(output_dir, final_file_name)

                with open(output_path, "wb") as f:
                    f.write(file_data)

                print(f"  ✓ Saved: {final_file_name} ({len(file_data):,} bytes) ({content_type}) -> {output_path}")
                print(f"    Description: {file_description}")

            except Exception as e:
                print(f"  ✗ Failed to save {getattr(file_bytesio, 'name', 'unknown')}: {e}")

    # Handle legacy dictionary format
    elif isinstance(files, dict):
        print(f"Agent generated {len(files)} file(s):")
        os.makedirs(output_dir, exist_ok=True)

        for file_path, file_content in files.items():
            original_file_name = file_path.split("/")[-1]

            try:
                base64_content, detected_mime_type = extract_base64_content(file_content)

                file_data = base64.b64decode(base64_content)

                final_file_name = original_file_name

                if detected_mime_type and "." not in original_file_name:
                    extension = get_file_extension_from_mime(detected_mime_type)
                    if extension:
                        final_file_name = original_file_name + extension

                output_path = os.path.join(output_dir, final_file_name)

                with open(output_path, "wb") as f:
                    f.write(file_data)

                mime_info = f" ({detected_mime_type})" if detected_mime_type else ""
                print(f"  ✓ Saved: {final_file_name} ({len(file_data):,} bytes){mime_info} -> {output_path}")

            except Exception as e:
                print(f"  ✗ Failed to save {original_file_name}: {e}")
                preview = file_content[:100] + "..." if len(file_content) > 100 else file_content
                print(f"    Content preview: {preview}")

    else:
        print(f"Unsupported file format: {type(files)}")


if __name__ == "__main__":
    csv_file_io = read_file_as_bytesio(
        file_path=FILE_PATH, filename=FILE_PATH.split("/")[-1], description=FILE_DESCRIPTION
    )

    output, steps, files = run_workflow(prompt=PROMPT, files_to_upload=[csv_file_io])

    logger.info("---------------------------------Result-------------------------------------")
    logger.info(output)
    save_agent_files(files)
